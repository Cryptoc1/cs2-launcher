@page "/"

@implements IAsyncDisposable

@inject ElementInterop ElementInterop
@inject LocalStorageInterop LocalStorage
@inject NavigationManager Navigation

<PageTitle>Console: @(!string.IsNullOrEmpty(Host) ? Host : "Connecting...")</PageTitle>

<main class="antialiased font-medium font-mono min-h-screen mx-auto overflow-y-auto overscroll-contain p-2 scroll-smooth w-full" @onclick="@OnMainClicked">
    @if (!string.IsNullOrEmpty(ConnectError))
    {
        <div class="flex flex-row items-center p-2">
            <span class="flex items-center pr-2 text-rose-400/80">
                <Icon Name="@IconName.Error" />
            </span>
            <samp class="text-rose-300">@ConnectError</samp>
        </div>

        <button class="flex flex-row items-center p-2 hover:underline" @onclick="@OnRetryClicked">
            <samp>Retry?</samp>
        </button>
    }
    else if (!string.IsNullOrEmpty(Host))
    {
        <Virtualize Items="@Entries" Context="entry">
            <div class="p-2" @key="@entry.Key">
                <div class="flex flex-row items-center">
                    <span class=@ClassNames.Combine("flex items-center pr-2", (entry.Value.IsError ? "text-rose-400" : entry.Value.IsExecuting ? "text-amber-400" : "text-green-300")+ "/80")>
                        <Icon Name="@(entry.Value.IsError ? IconName.Error : entry.Value.IsExecuting ? IconName.Pending : IconName.Circle)" />
                    </span>
                    <span class="whitespace-nowrap">@Host</span>
                    <Icon Name="@IconName.ChevronRight" />
                    <span class="ml-2 py-2">@entry.Value.Command</span>
                </div>

                @if (entry.Value.IsExecuting)
                {
                    <div class="flex flex-row items-center py-1">
                        <Loading Text="Executing Command..." />
                    </div>
                }
                else
                {
                    <samp class=@ClassNames.Combine("font-normal", entry.Value.IsError ? "text-rose-300" : "")>@entry.Value.Text</samp>
                }
            </div>
        </Virtualize>

        <EditForm class="flex flex-row items-center p-2" Model="@Form" OnValidSubmit="OnSubmit">
            <DataAnnotationsValidator />
            <span class="flex-row inline-flex items-center mr-2">
                <span class="flex items-center pr-2 text-green-300/80">
                    <Icon Name="IconName.CloudCircle" />
                </span>
                <span class="whitespace-nowrap">@Host</span>
                <Icon Name="@IconName.ChevronRight" />
            </span>
            <InputText class="bg-transparent border-none outline-none px-0 w-full focus:ring-0" @ref="@commandInput" @bind-Value="@Form.Command" @onblur="@OnCommandInputBlur" @onfocus="@OnCommandInputFocus" @onkeydown="@OnCommandInputKeyDown" type="text" autofocus />
        </EditForm>
    }
    else
    {
        <Loading Text="Connecting..." />
    }
</main>

@code {

    private const string HistoryStorageKey = "console.history";
    private const int MaxEntries = 250;

    private InputText? commandInput;
    private ConsoleSignaler signaler = default!;
    private List<IDisposable>? signals;

    private string? ConnectError { get; set; }
    private Dictionary<long, CommandEntry> Entries { get; set; } = new(MaxEntries);
    private ConsoleForm Form { get; set; } = new();
    private List<string> History { get; set; } = new(MaxEntries);
    private string Host { get; set; }
    private bool IsCommandInputFocused { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            signals = [signaler.On<ConsoleSignals.ConnectFailed>(OnConnectFailed),
signaler.On<ConsoleSignals.Connected>(OnConnected),
signaler.On<ConsoleSignals.ExecutedCommand>(OnExecutedCommand),
signaler.On<ConsoleSignals.ExecuteCommandFailed>(OnExecuteCommandFailed)];

            var connect = signaler.Connect();
            History = await LocalStorage.Get<List<string>>(HistoryStorageKey) ?? [];
            History.EnsureCapacity(MaxEntries);

            await connect;
        }
    }

    private void OnCommandInputBlur()
    {
        IsCommandInputFocused = false;
    }

    private void OnCommandInputFocus()
    {
        Form.Offset = 0;
        IsCommandInputFocused = true;
    }

    private async Task OnCommandInputKeyDown(KeyboardEventArgs e)
    {
        var handled = await (e.Code switch
        {
            "ArrowDown" => OnArrowDown(),
            "ArrowUp" => OnArrowUp(),
            _ => new(false)
        });

        if (handled && string.IsNullOrEmpty(Form.Command))
        {
            Form.Offset = 0;
        }

        async ValueTask<bool> OnArrowDown()
        {
            var offset = ((History.Count - 1) - Form.Offset) + 1;
            if (offset >= 0 && offset < History.Count)
            {
                Form.Command = History[offset];
                Form.Offset--;
                await InvokeAsync(StateHasChanged);

                await Task.Delay(75);
                await TryFocusCommandInput();

                return true;
            }

            return false;
        }

        async ValueTask<bool> OnArrowUp()
        {
            var offset = (History.Count - 1) - Form.Offset;
            if (offset >= 0)
            {
                Form.Command = History[offset];
                Form.Offset++;
                await InvokeAsync(StateHasChanged);

                await Task.Delay(75);
                await TryFocusCommandInput();

                return true;
            }

            return false;
        }
    }

    private async Task OnExecutedCommand(ConsoleSignals.ExecutedCommand command)
    {
        if (Entries.TryGetValue(command.Token, out var entry))
        {
            Entries[command.Token] = entry with
                {
                    IsExecuting = false,
                    Text = command.Text
                };

            var render = InvokeAsync(StateHasChanged);

            await LocalStorage.Set(HistoryStorageKey, History);
            await render;
        }
    }

    private Task OnExecuteCommandFailed(ConsoleSignals.ExecuteCommandFailed failure)
    {
        if (Entries.TryGetValue(failure.Token, out var entry))
        {
            Entries[failure.Token] = entry with
                {
                    IsExecuting = false,
                    IsError = true,
                    Text = failure.Error,
                };

            return InvokeAsync(StateHasChanged);
        }

        return Task.CompletedTask;
    }

    private async Task OnConnectFailed(ConsoleSignals.ConnectFailed failure)
    {
        await signaler.Disconnect();

        ConnectError = failure.Error;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnConnected(ConsoleSignals.Connected connected)
    {
        ConnectError = "";
        Host = connected.Host;

        await InvokeAsync(StateHasChanged);
        await TryFocusCommandInput();
    }

    protected override void OnInitialized()
    {
        Form ??= new();
        signaler = new(Navigation);
    }

    private async Task OnMainClicked()
    {
        if (commandInput?.Element.HasValue is true && !IsCommandInputFocused)
        {
            await TryFocusCommandInput();
        }
    }

    private async Task OnRetryClicked()
    {
        await signaler.Disconnect();

        ConnectError = "";
        await InvokeAsync(StateHasChanged);

        await signaler.Connect();
    }

    private async Task OnSubmit()
    {
        var signal = new ConsoleSignals.ExecuteCommand(Form.Command, DateTime.UtcNow.Ticks);
        if (Entries.Count >= MaxEntries)
        {
            var token = Entries.Keys.First();
            Entries.Remove(token);
        }

        Entries.Add(signal.Token, new(signal.Command));
        if (History.Count >= MaxEntries)
        {
            History.RemoveAt(History.Count - 1);
        }
        else if (History.ElementAtOrDefault(History.Count - 1) != signal.Command)
        {
            History.Add(signal.Command);
        }

        await signaler.Send(signal);
        Form = new();

        await Task.Delay(75);
        await TryFocusCommandInput();
    }

    public async ValueTask DisposeAsync()
    {
        signals?.ForEach(signal => signal.Dispose());
        signals?.Clear();

        if (signaler is not null)
        {
            await signaler.DisposeAsync();
        }
    }

    private ValueTask TryFocusCommandInput()
    {
        if (commandInput?.Element.HasValue is true)
        {
            return ElementInterop.FocusAndSelectEnd(commandInput.Element.Value);
        }

        return ValueTask.CompletedTask;
    }

    private sealed record CommandEntry(string Command, bool IsExecuting = true, string? Text = default)
    {
        public bool IsError { get; init; }
    }

    public sealed class ConsoleForm
    {
        [Required]
        public string Command { get; set; }

        public int Offset { get; set; }
    }

}