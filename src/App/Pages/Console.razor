@using System.Diagnostics.CodeAnalysis
@using CS2Launcher.AspNetCore.App.Abstractions.Signals
@using CS2Launcher.AspNetCore.App.Infrastructure

@page "/console"

@inherits Stateful<ConsoleState>
@implements IAsyncDisposable

@inject ElementInterop ElementInterop
@inject LocalStorageInterop LocalStorage
@inject NavigationManager Navigation

<PageTitle>CS2Launcher: Console - @(State.IsLoading ? "Connecting..." : State.Host ?? State.ConnectError)</PageTitle>

<main class="font-medium font-mono min-h-full mx-auto overflow-y-auto p-2 scroll-smooth w-full" @onclick="@OnMainClicked">
    @if (!State.IsLoading)
    {
        @if (!string.IsNullOrEmpty(State.ConnectError))
        {
            <div class="flex flex-row items-center p-2">
                <span class="flex items-center pr-2 text-ctp-red/80">
                    <Icon Name="@IconName.Error" />
                </span>
                <samp class="text-ctp-red">@State.ConnectError</samp>
            </div>

            <button type="button" @onclick="@OnRetryClicked">Retry?</button>
        }
        else
        {
            <Virtualize Items="@State.Entries" Context="entry">
                <div class="p-2" @key="@entry.Key">
                    <div class="flex flex-row items-center">
                        <span class=@ClassNames.Combine("flex items-center pr-2", (entry.Value.IsError ? "text-ctp-red" : entry.Value.IsExecuting ? "text-ctp-yellow/80" : "text-ctp-green/80"))>
                            <Icon Name="@(entry.Value.IsError ? IconName.Error : entry.Value.IsExecuting ? IconName.Pending : IconName.Circle)" />
                        </span>
                        <span class="whitespace-nowrap">@State.Host</span>
                        <Icon Name="@IconName.ChevronRight" />
                        <span class="ml-2 py-2">@entry.Value.Command</span>
                    </div>

                    @if (entry.Value.IsExecuting)
                    {
                        <div class="flex flex-row items-center py-1">
                            <Loading Text="Executing Command..." />
                        </div>
                    }
                    else
                    {
                        <samp class=@ClassNames.Combine("font-normal", entry.Value.IsError ? "text-ctp-red" : "")>@entry.Value.Text</samp>
                    }
                </div>
            </Virtualize>

            <EditForm class="flex flex-row items-center p-2" Model="@State.Form" OnValidSubmit="OnSubmit">
                <FormValidator />
                <span class="flex-row inline-flex items-center mr-2">
                    <span class="flex items-center pr-2 text-ctp-green/80">
                        <Icon Name="IconName.CloudCircle" />
                    </span>
                    <span class="whitespace-nowrap">@State.Host</span>
                    <Icon Name="@IconName.ChevronRight" />
                </span>
                <InputText class="bg-transparent border-none input-no-defaults outline-none px-0 w-full focus:ring-0" @ref="@commandInput" @bind-Value="@State.Form.Command" @onblur="@OnCommandInputBlur" @onfocus="@OnCommandInputFocus" @onkeydown="@OnCommandInputKeyDown" type="text" autofocus />
            </EditForm>
        }
    }
    else
    {
        <div class="flex flex-row p-2">
            <Loading Text="Connecting..." />
        </div>
    }
</main>

@code {

    private InputText? commandInput;

    [DisallowNull]
    private ConsoleSignaler signaler;
    private List<IDisposable>? signals;

    private bool IsCommandInputFocused { get; set; }

    public async ValueTask DisposeAsync()
    {
        signals?.ForEach(signal => signal.Dispose());
        signals?.Clear();

        if (signaler is not null)
        {
            await signaler.DisposeAsync();
            signaler = default!;
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            signals = [signaler.On<ConsoleSignals.ConnectFailed>(OnConnectFailed),
signaler.On<ConsoleSignals.Connected>(OnConnected),
signaler.On<ConsoleSignals.ExecutedCommand>(OnExecutedCommand),
signaler.On<ConsoleSignals.ExecuteCommandFailed>(OnExecuteCommandFailed)];

            return Mutate(state => ConsoleState.Load(LocalStorage, signaler, state));
        }

        return Task.CompletedTask;
    }

    private void OnCommandInputBlur()
    {
        IsCommandInputFocused = false;
    }

    private async Task OnCommandInputFocus()
    {
        IsCommandInputFocused = true;
        await Mutate(state =>
        {
            state.Form.Offset = 0;
            return state;
        });
    }

    private async Task OnCommandInputKeyDown(KeyboardEventArgs e)
    {
        var handled = await (e.Code switch
        {
            "ArrowDown" => OnArrowDown(),
            "ArrowUp" => OnArrowUp(),
            _ => new(false)
        });

        if (handled)
        {
            await Task.Delay(75);
            await TryFocusCommandInput();
        }

        ValueTask<bool> OnArrowDown()
        {
            var offset = ((State.History.Count - 1) - State.Form.Offset) + 1;
            if (offset >= 0 && offset < State.History.Count)
            {
                return Mutate(state =>
                {
                    state.Form.Offset = Math.Max(0, state.Form.Offset - 1);
                    if (string.IsNullOrWhiteSpace(state.Form.Command = state.History[offset]))
                    {
                        state.Form.Offset = 0;
                    }

                    return state;
                });
            }

            return new(false);
        }

        ValueTask<bool> OnArrowUp()
        {
            var offset = (State.History.Count - 1) - State.Form.Offset;
            if (offset >= 0)
            {
                return Mutate(state =>
                {
                    state.Form.Offset++;
                    if (string.IsNullOrWhiteSpace(state.Form.Command = state.History[offset]))
                    {
                        state.Form.Offset = 0;
                    }

                    return state;
                });
            }

            return new(false);
        }
    }

    private Task OnExecutedCommand(ConsoleSignals.ExecutedCommand command) => Mutate(state => ConsoleState.OnExecutedCommand(LocalStorage, command, state));

    private async Task OnExecuteCommandFailed(ConsoleSignals.ExecuteCommandFailed failure) => await Mutate(state => ConsoleState.OnExecuteCommandFailed(failure, state));

    private async Task OnConnectFailed(ConsoleSignals.ConnectFailed failure)
    {
        await Mutate(state => ConsoleState.OnConnectFailed(failure, state));
        await signaler.Disconnect();
    }

    private async Task OnConnected(ConsoleSignals.Connected connected)
    {
        await Mutate(state => ConsoleState.OnConnected(connected, state));
        await TryFocusCommandInput();
    }

    protected override void OnInitialized()
    {
        signaler = new(Navigation);
    }

    private async Task OnMainClicked()
    {
        if (commandInput?.Element.HasValue is true && !IsCommandInputFocused)
        {
            await TryFocusCommandInput();
        }
    }

    private Task OnRetryClicked() => Mutate(state => ConsoleState.Reconnect(signaler, state));

    private async Task OnSubmit()
    {
        if (await Mutate(state => ConsoleState.ExecuteCommand(signaler, state)))
        {
            await Task.Delay(75);
            await TryFocusCommandInput();
        }
    }

    private ValueTask TryFocusCommandInput()
    {
        if (commandInput?.Element.HasValue is true)
        {
            return ElementInterop.FocusAndSelectEnd(commandInput.Element.Value);
        }

        return ValueTask.CompletedTask;
    }
}