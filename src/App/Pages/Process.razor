@using System.Diagnostics.CodeAnalysis
@using CS2Launcher.AspNetCore.App.Abstractions.Api
@using CS2Launcher.AspNetCore.App.Abstractions.Signals
@using CS2Launcher.AspNetCore.App.Infrastructure

@page "/process"

@inherits Stateful<ProcessState>
@implements IAsyncDisposable

@inject ILauncherApiClient Api
@inject NavigationManager Navigation

<PageTitle>CS2Launcher: Process</PageTitle>

<PageMain Heading="Server Process">
    @if (!State.IsLoading)
    {
        <section class="gap-4 grid grid-cols-3 my-2">
            <Alert class="col-span-3" Type="@ToAlertType(State.Status)">
                <Heading>
                    Server is
                    @if (State.IsServerResetting)
                    {
                        <Loading />
                    }
                    else
                    {
                        <code class="bg-ctp-surface1 font-semibold p-0.5 px-1 rounded-sm text-sm">@State.Status.ToString()</code>
                    }
                </Heading>
                <Content>
                    <div class="flex flex-row py-2 space-x-2">
                        <button type="button" @onclick="@OnRestartClicked" disabled="@(State.IsServerResetting || State.Status is ServerStatus.Disabled or ServerStatus.Starting)">@(State.Status is ServerStatus.Running ? "Restart" : "Start")</button>
                        <button type="button" @onclick="@OnTerminateClicked" disabled="@(State.IsServerResetting || State.Status is ServerStatus.Disabled or not ServerStatus.Running)">Terminate</button>
                    </div>
                </Content>
            </Alert>

            <Alert Icon="@IconName.Memory">
                <Heading>Memory</Heading>
                <Content>
                    <p>Paged: @FormatGigaBytes(State.Metrics.Memory.Paged)</p>
                    <p>Virtual: @FormatGigaBytes(State.Metrics.Memory.Virtual)</p>
                    <p>Working: @FormatGigaBytes(State.Metrics.Memory.Working)</p>
                </Content>
            </Alert>

            @if (State.Metrics.Memory.Peak is not null)
            {
                <Alert Icon="@IconName.MemoryAlt">
                    <Heading>Memory (peak)</Heading>
                    <Content>
                        <p>Paged: @FormatGigaBytes(State.Metrics.Memory.Peak.Paged)</p>
                        <p>Virtual: @FormatGigaBytes(State.Metrics.Memory.Peak.Virtual)</p>
                        <p>Working: @FormatGigaBytes(State.Metrics.Memory.Peak.Working)</p>
                    </Content>
                </Alert>
            }

            <Alert Icon="@IconName.Pace">
                <Heading>Processor Time</Heading>
                <Content>
                    <p>Privileged: @FormatTime(State.Metrics.Processor.Privileged)</p>
                    <p>User: @FormatTime(State.Metrics.Processor.User)</p>
                    <p>Total: @FormatTime(State.Metrics.Processor.Total)</p>
                </Content>
            </Alert>
        </section>
    }
    else
    {
        <section class="flex flex-row py-2">
            <Loading />
        </section>
    }
</PageMain>

@code {

    [DisallowNull]
    private MetricsSignaler signaler;
    private List<IDisposable>? signals;

    public async ValueTask DisposeAsync()
    {
        signals?.ForEach(signal => signal.Dispose());
        signals?.Clear();

        if (signaler is not null)
        {
            await signaler.DisposeAsync();
            signaler = default!;
        }
    }

    private static string FormatGigaBytes(long bytes) => $"{((bytes / 1024f) / 1024f) / 1024f:0.00}GB";
    private static string FormatTime(TimeSpan time) => $@"{time:hh\:mm\:ss}";

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            signaler = new(Navigation);
            signals = [signaler.On<MetricsSignals.Report>(OnMetricsReported)];

            return Mutate(state => ProcessState.Load(Api.Server, signaler, state));
        }

        return Task.CompletedTask;
    }

    private async Task OnMetricsReported(MetricsSignals.Report report) => await Mutate(state => ProcessState.OnReport(report, state));

    private Task OnRestartClicked() => Mutate(state => ProcessState.RestartServer(Api.Server, state));

    private Task OnTerminateClicked() => Mutate(state => ProcessState.StopServer(Api.Server, state));

    private static AlertType ToAlertType(ServerStatus status) => status switch
    {
        ServerStatus.Running => AlertType.Information,
        ServerStatus.Crashed or ServerStatus.Disabled => AlertType.Critical,
        _ => AlertType.Warning
    };
}