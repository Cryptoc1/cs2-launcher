@using CS2Launcher.AspNetCore.App.Abstractions.Api
@using CS2Launcher.AspNetCore.App.Abstractions.Signals
@using CS2Launcher.AspNetCore.App.Infrastructure

@page "/process"

@inherits Stateful<ProcessState>
@implements IAsyncDisposable

@inject ILauncherApiClient Api
@inject NavigationManager Navigation

<PageMain Heading="Server Process" IsLoading="@State.IsLoading">
    <section class="gap-4 grid grid-cols-3 my-2">
        <Alert class="col-span-3" Type="@ToAlertType(State.Status)">
            <Heading>
                Server is
                @if (State.IsServerResetting)
                {
                    <Loading />
                }
                else
                {
                    <code class="bg-ctp-surface1 font-semibold p-0.5 px-1 rounded-sm text-sm">@State.Status.ToString()</code>
                }
            </Heading>
            <Content>
                <div class="flex flex-row py-2 space-x-2">
                    <button type="button" @onclick="@OnRestartClicked" disabled="@(State.IsServerResetting || State.Status is ServerStatus.Disabled or ServerStatus.Starting)">@(State.Status is ServerStatus.Running ? "Restart" : "Start")</button>
                    <button type="button" @onclick="@OnTerminateClicked" disabled="@(State.IsServerResetting || State.Status is ServerStatus.Disabled or not ServerStatus.Running)">Terminate</button>
                </div>
            </Content>
        </Alert>

        <Alert Icon="@IconName.Memory">
            <Heading>Memory</Heading>
            <Content>
                <p>Paged: @FormatGigaBytes(State.Metrics.Memory.Paged)</p>
                <p>Virtual: @FormatGigaBytes(State.Metrics.Memory.Virtual)</p>
                <p>Working: @FormatGigaBytes(State.Metrics.Memory.Working)</p>
            </Content>
        </Alert>

        @if (State.Metrics.Memory.Peak is not null)
        {
            <Alert Icon="@IconName.MemoryAlt">
                <Heading>Memory (peak)</Heading>
                <Content>
                    <p>Paged: @FormatGigaBytes(State.Metrics.Memory.Peak.Paged)</p>
                    <p>Virtual: @FormatGigaBytes(State.Metrics.Memory.Peak.Virtual)</p>
                    <p>Working: @FormatGigaBytes(State.Metrics.Memory.Peak.Working)</p>
                </Content>
            </Alert>
        }

        <Alert Icon="@IconName.Pace">
            <Heading>Processor</Heading>
            <Content>
                <p>Privileged Time: @FormatTime(State.Metrics.Processor.Timings.Privileged)</p>
                <p>User Time: @FormatTime(State.Metrics.Processor.Timings.User)</p>
                <p>Total Time: @FormatTime(State.Metrics.Processor.Timings.Total)</p>
                <p>Threads: @State.Metrics.Processor.Threads</p>
            </Content>
        </Alert>
    </section>
</PageMain>

@code {

    [DisallowNull]
    private MetricsSignaler signaler;
    private List<IDisposable>? signals;

    public async ValueTask DisposeAsync()
    {
        signals?.ForEach(signal => signal.Dispose());
        signals?.Clear();

        if (signaler is not null)
        {
            await signaler.DisposeAsync();
            signaler = default!;
        }
    }

    private static string FormatGigaBytes(long bytes) => $"{((bytes / 1024f) / 1024f) / 1024f:0.00}GB";
    private static string FormatTime(TimeSpan time) => $@"{time:hh\:mm\:ss}";

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            signaler = new(Navigation);
            signals = [signaler.On<MetricsSignals.Report>(OnMetricsReported)];

            return Mutate(state => ProcessState.Load(Api.Server, signaler, state));
        }

        return Task.CompletedTask;
    }

    private async Task OnMetricsReported(MetricsSignals.Report report) => await Mutate(state => ProcessState.OnReport(report, state));

    private Task OnRestartClicked() => Mutate(state => ProcessState.RestartServer(Api.Server, state));

    private Task OnTerminateClicked() => Mutate(state => ProcessState.StopServer(Api.Server, state));

    private static AlertType ToAlertType(ServerStatus status) => status switch
    {
        ServerStatus.Running => AlertType.Information,
        ServerStatus.Crashed or ServerStatus.Disabled => AlertType.Critical,
        _ => AlertType.Warning
    };
}